/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/health": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Health check */
        get: operations["getHealth"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/checkouts": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List checkouts
         * @description Returns a paginated list of checkouts, newest first.
         */
        get: operations["listCheckouts"];
        put?: never;
        /**
         * Create a checkout
         * @description Creates a new payment checkout and returns a deposit address.
         *     Supports idempotency via the `Idempotency-Key` header.
         */
        post: operations["createCheckout"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/checkouts/{checkout_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get a checkout */
        get: operations["getCheckout"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/checkouts/{checkout_id}/status": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get checkout status
         * @description Lightweight status endpoint for polling. Returns current status,
         *     confirmations, and polling hints.
         */
        get: operations["getCheckoutStatus"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/webhooks": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List webhook endpoints */
        get: operations["listWebhookEndpoints"];
        put?: never;
        /** Create a webhook endpoint */
        post: operations["createWebhookEndpoint"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/webhooks/{webhook_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get a webhook endpoint */
        get: operations["getWebhookEndpoint"];
        put?: never;
        post?: never;
        /** Delete a webhook endpoint */
        delete: operations["deleteWebhookEndpoint"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/events": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List events
         * @description Returns a paginated list of webhook events, newest first.
         *     Useful for replaying missed webhooks or debugging.
         */
        get: operations["listEvents"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/events/{event_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get an event */
        get: operations["getEvent"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        /**
         * @description Blockchain network
         * @enum {string}
         */
        Chain: "tron" | "arbitrum";
        /**
         * @description Stablecoin token
         * @enum {string}
         */
        Token: "USDT" | "USDC";
        /**
         * @description - `pending` — Waiting for payment
         *     - `detected` — Transaction seen on-chain, unconfirmed
         *     - `confirming` — Confirmations in progress
         *     - `confirmed` — Payment fully confirmed (terminal)
         *     - `expired` — Checkout TTL exceeded without payment (terminal)
         *     - `failed` — Unrecoverable error (terminal)
         * @enum {string}
         */
        CheckoutStatus: "pending" | "detected" | "confirming" | "confirmed" | "expired" | "failed";
        /** @enum {string} */
        EventType: "checkout.created" | "checkout.payment_detected" | "checkout.confirming" | "checkout.completed" | "checkout.expired" | "checkout.failed";
        CreateCheckoutRequest: {
            /**
             * Format: double
             * @description Amount in USD
             * @example 49.99
             */
            amount_usd: number;
            chain: components["schemas"]["Chain"];
            token: components["schemas"]["Token"];
            /**
             * @description Checkout TTL in seconds (5 min to 24 hr)
             * @default 1800
             */
            expires_in_seconds: number;
            /**
             * @description Arbitrary key-value pairs (max 20 keys, max 500 chars per value)
             * @example {
             *       "order_id": "ord_12345",
             *       "customer_email": "user@example.com"
             *     }
             */
            metadata?: {
                [key: string]: string;
            };
        };
        CreateWebhookRequest: {
            /**
             * Format: uri
             * @description HTTPS endpoint to receive events
             * @example https://example.com/webhooks/billing
             */
            url: string;
            /** @description Event types to subscribe to */
            events: components["schemas"]["EventType"][];
            /** @description Human-readable label */
            description?: string;
        };
        Checkout: {
            /**
             * @description Unique identifier (prefixed `co_`)
             * @example co_1a2b3c4d5e
             */
            checkout_id?: string;
            /** @description Blockchain address to send funds to */
            deposit_address?: string;
            chain?: components["schemas"]["Chain"];
            token?: components["schemas"]["Token"];
            /**
             * Format: double
             * @description Original USD amount
             */
            amount_usd?: number;
            /**
             * @description Token amount in smallest unit (string to avoid precision loss)
             * @example 49990000
             */
            amount_atomic?: string;
            status?: components["schemas"]["CheckoutStatus"];
            /** @description On-chain transaction hash (null until detected) */
            tx_hash?: string | null;
            /** @description Current confirmation count */
            confirmations?: number;
            /**
             * @description Confirmations needed for this chain
             * @example 19
             */
            required_confirmations?: number;
            /** Format: date-time */
            expires_at?: string;
            /** Format: date-time */
            detected_at?: string | null;
            /** Format: date-time */
            confirmed_at?: string | null;
            /** Format: date-time */
            created_at?: string;
            metadata?: {
                [key: string]: string;
            };
        };
        CheckoutStatusResponse: {
            checkout_id?: string;
            status?: components["schemas"]["CheckoutStatus"];
            tx_hash?: string | null;
            confirmations?: number;
            required_confirmations?: number;
            /** Format: date-time */
            detected_at?: string | null;
            /** Format: date-time */
            confirmed_at?: string | null;
            /**
             * @description Suggested polling interval in milliseconds
             * @example 2000
             */
            polling_interval_ms?: number;
        };
        CheckoutList: {
            data?: components["schemas"]["Checkout"][];
            has_more?: boolean;
            next_cursor?: string | null;
        };
        WebhookEndpoint: {
            /** @description Unique identifier (prefixed `we_`) */
            webhook_id?: string;
            /** Format: uri */
            url?: string;
            events?: components["schemas"]["EventType"][];
            /**
             * @description HMAC signing secret (prefixed `whsec_`).
             *     Only returned on creation — store it securely.
             */
            secret?: string;
            description?: string | null;
            /** @enum {string} */
            status?: "active" | "disabled";
            /** Format: date-time */
            created_at?: string;
        };
        WebhookEndpointList: {
            data?: components["schemas"]["WebhookEndpoint"][];
            has_more?: boolean;
            next_cursor?: string | null;
        };
        Event: {
            /** @description Unique identifier (prefixed `evt_`) */
            event_id?: string;
            type?: components["schemas"]["EventType"];
            checkout_id?: string;
            data?: components["schemas"]["Checkout"];
            /** Format: date-time */
            created_at?: string;
        };
        EventList: {
            data?: components["schemas"]["Event"][];
            has_more?: boolean;
            next_cursor?: string | null;
        };
        HealthResponse: {
            /** @enum {string} */
            status?: "healthy";
            /** @example 1.0.0 */
            version?: string;
        };
        ErrorResponse: {
            error: {
                /** @enum {string} */
                type: "invalid_request" | "authentication_error" | "not_found" | "idempotency_conflict" | "rate_limited" | "internal_error";
                /**
                 * @description Machine-readable error code
                 * @example checkout_not_found
                 */
                code: string;
                /**
                 * @description Human-readable message
                 * @example No checkout found with ID co_abc123
                 */
                message: string;
                /** @description The request parameter that caused the error */
                param?: string | null;
            };
        };
    };
    responses: {
        /** @description Invalid request */
        BadRequest: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                /**
                 * @example {
                 *       "error": {
                 *         "type": "invalid_request",
                 *         "code": "missing_required_field",
                 *         "message": "The 'amount_usd' field is required.",
                 *         "param": "amount_usd"
                 *       }
                 *     }
                 */
                "application/json": components["schemas"]["ErrorResponse"];
            };
        };
        /** @description Authentication failed */
        Unauthorized: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                /**
                 * @example {
                 *       "error": {
                 *         "type": "authentication_error",
                 *         "code": "api_key_invalid",
                 *         "message": "The API key provided is invalid.",
                 *         "param": null
                 *       }
                 *     }
                 */
                "application/json": components["schemas"]["ErrorResponse"];
            };
        };
        /** @description Resource not found */
        NotFound: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                /**
                 * @example {
                 *       "error": {
                 *         "type": "not_found",
                 *         "code": "checkout_not_found",
                 *         "message": "No checkout found with ID co_abc123.",
                 *         "param": "checkout_id"
                 *       }
                 *     }
                 */
                "application/json": components["schemas"]["ErrorResponse"];
            };
        };
        /** @description Idempotency key reused with different parameters */
        IdempotencyConflict: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                /**
                 * @example {
                 *       "error": {
                 *         "type": "idempotency_conflict",
                 *         "code": "idempotency_key_reused",
                 *         "message": "This idempotency key was already used with different parameters.",
                 *         "param": null
                 *       }
                 *     }
                 */
                "application/json": components["schemas"]["ErrorResponse"];
            };
        };
        /** @description Rate limit exceeded */
        RateLimited: {
            headers: {
                /** @description Requests allowed per window */
                "X-RateLimit-Limit"?: number;
                /** @description Requests remaining in current window */
                "X-RateLimit-Remaining"?: number;
                /** @description Unix timestamp when the window resets */
                "X-RateLimit-Reset"?: number;
                /** @description Seconds to wait before retrying */
                "Retry-After"?: number;
                [name: string]: unknown;
            };
            content: {
                /**
                 * @example {
                 *       "error": {
                 *         "type": "rate_limited",
                 *         "code": "too_many_requests",
                 *         "message": "Rate limit exceeded. Retry after 30 seconds.",
                 *         "param": null
                 *       }
                 *     }
                 */
                "application/json": components["schemas"]["ErrorResponse"];
            };
        };
        /** @description Internal server error */
        InternalError: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                /**
                 * @example {
                 *       "error": {
                 *         "type": "internal_error",
                 *         "code": "internal_server_error",
                 *         "message": "An unexpected error occurred.",
                 *         "param": null
                 *       }
                 *     }
                 */
                "application/json": components["schemas"]["ErrorResponse"];
            };
        };
    };
    parameters: {
        /** @description The checkout identifier (prefixed `co_`) */
        CheckoutId: string;
        /** @description The webhook endpoint identifier (prefixed `we_`) */
        WebhookId: string;
        /**
         * @description Client-generated UUID. If a request with the same key was already
         *     processed, the original response is returned. Keys expire after 24h.
         */
        IdempotencyKey: string;
        /** @description Opaque cursor for pagination. Omit for the first page. */
        Cursor: string;
        /** @description Number of items per page. */
        Limit: number;
    };
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
    getHealth: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Service is healthy */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HealthResponse"];
                };
            };
            429: components["responses"]["RateLimited"];
            500: components["responses"]["InternalError"];
        };
    };
    listCheckouts: {
        parameters: {
            query?: {
                /** @description Opaque cursor for pagination. Omit for the first page. */
                cursor?: components["parameters"]["Cursor"];
                /** @description Number of items per page. */
                limit?: components["parameters"]["Limit"];
                status?: components["schemas"]["CheckoutStatus"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Checkout list */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CheckoutList"];
                };
            };
            401: components["responses"]["Unauthorized"];
            429: components["responses"]["RateLimited"];
            500: components["responses"]["InternalError"];
        };
    };
    createCheckout: {
        parameters: {
            query?: never;
            header?: {
                /**
                 * @description Client-generated UUID. If a request with the same key was already
                 *     processed, the original response is returned. Keys expire after 24h.
                 */
                "Idempotency-Key"?: components["parameters"]["IdempotencyKey"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateCheckoutRequest"];
            };
        };
        responses: {
            /** @description Checkout created */
            201: {
                headers: {
                    "Idempotency-Key"?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Checkout"];
                };
            };
            400: components["responses"]["BadRequest"];
            401: components["responses"]["Unauthorized"];
            409: components["responses"]["IdempotencyConflict"];
            429: components["responses"]["RateLimited"];
            500: components["responses"]["InternalError"];
        };
    };
    getCheckout: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The checkout identifier (prefixed `co_`) */
                checkout_id: components["parameters"]["CheckoutId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Checkout details */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Checkout"];
                };
            };
            401: components["responses"]["Unauthorized"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["RateLimited"];
            500: components["responses"]["InternalError"];
        };
    };
    getCheckoutStatus: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The checkout identifier (prefixed `co_`) */
                checkout_id: components["parameters"]["CheckoutId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Checkout status */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CheckoutStatusResponse"];
                };
            };
            401: components["responses"]["Unauthorized"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["RateLimited"];
            500: components["responses"]["InternalError"];
        };
    };
    listWebhookEndpoints: {
        parameters: {
            query?: {
                /** @description Opaque cursor for pagination. Omit for the first page. */
                cursor?: components["parameters"]["Cursor"];
                /** @description Number of items per page. */
                limit?: components["parameters"]["Limit"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Webhook endpoint list */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["WebhookEndpointList"];
                };
            };
            401: components["responses"]["Unauthorized"];
            429: components["responses"]["RateLimited"];
            500: components["responses"]["InternalError"];
        };
    };
    createWebhookEndpoint: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateWebhookRequest"];
            };
        };
        responses: {
            /** @description Webhook endpoint created */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["WebhookEndpoint"];
                };
            };
            400: components["responses"]["BadRequest"];
            401: components["responses"]["Unauthorized"];
            429: components["responses"]["RateLimited"];
            500: components["responses"]["InternalError"];
        };
    };
    getWebhookEndpoint: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The webhook endpoint identifier (prefixed `we_`) */
                webhook_id: components["parameters"]["WebhookId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Webhook endpoint details */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["WebhookEndpoint"];
                };
            };
            401: components["responses"]["Unauthorized"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["RateLimited"];
            500: components["responses"]["InternalError"];
        };
    };
    deleteWebhookEndpoint: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The webhook endpoint identifier (prefixed `we_`) */
                webhook_id: components["parameters"]["WebhookId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Webhook endpoint deleted */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            401: components["responses"]["Unauthorized"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["RateLimited"];
            500: components["responses"]["InternalError"];
        };
    };
    listEvents: {
        parameters: {
            query?: {
                /** @description Opaque cursor for pagination. Omit for the first page. */
                cursor?: components["parameters"]["Cursor"];
                /** @description Number of items per page. */
                limit?: components["parameters"]["Limit"];
                type?: components["schemas"]["EventType"];
                checkout_id?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Event list */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["EventList"];
                };
            };
            401: components["responses"]["Unauthorized"];
            429: components["responses"]["RateLimited"];
            500: components["responses"]["InternalError"];
        };
    };
    getEvent: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                event_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Event details */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Event"];
                };
            };
            401: components["responses"]["Unauthorized"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["RateLimited"];
            500: components["responses"]["InternalError"];
        };
    };
}
